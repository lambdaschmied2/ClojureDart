(ns cljd.reader
  (:require ["dart:io" :as io]
            ["dart:async" :as async]
            ["dart:collection" :as coll]
            ["dart:convert" :as convert]))

(def ^RegExp SPACE-REGEXP #"[\s,]*")

;; REFACTORING THE READER
;; Two goals:
;; * perfs
;; * synchronous read-string

; stack is interleaved state and fns
(deftype ReaderState [^List stack  ^coll/Queue q])

(defn resume! [^ReaderState {:flds [stack] :as state} ^String s ^int from ^int to]
  (loop [from from]
    (let [from ((.-last stack) state s from to)]
      (if (or (neg? from) (.-isEmpty stack))
        from
        (recur from)))))

(defn eof! [^ReaderState {:flds [stack] :as state}]
  (while (.-isNotEmpty stack)
    ((.-last stack) state)))

;; We are using the dart:convert classes to get us async and sync
;; It means we have to provide a Decoder.
;; What's interesting is what happens when a chunked conversion is started.
(deftype CljDecoder [^ReaderState state]
  :extends #/(convert/Converter String Object?)
  (convert [this s]
    (let [from (resume! state s 0 (.-length s))]
      (when (neg? from)
        (eof! state))
      (-> state .-q .-first)))
  (startChunkedConversion [_ out]
    (reify
      :extends convert/StringConversionSinkBase
      (close [_] (eof! state) (->> state .-q .-first (.add out)))
      (addSlice [this s from to is-last]
        (let [from (resume! state s from to)]
          (when (and (neg? from) is-last)
            (.close this)))))))

(defn do-read-token
  ([^ReaderState {:flds [q stack] :as state}]
   (let [n-2 (- (.-length stack) 2)
         ^StringBuffer sb (aget stack n-2)]
     (.-length! stack n-2)
     (-> state .-q (.add (interpret-token (.toString sb))))))
  ([^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
   (let [n-2 (- (.-length stack) 2)
         ^StringBuffer sb (aget stack n-2)]
     (loop [from from]
       (if (< from to)
         (if (terminating? s from)
           (do
             (.-length! stack n-2)
             (-> state .-q (.add (interpret-token (.toString sb))))
             from)
           (let [cu (.codeUnitAt s from)]
             (.writeCharCode sb cu)
             (recur (inc from))))
         -1)))))

(defn read-token
  [^ReaderState {:flds [stack] :as state} ^String s ^int from ^int to]
  (doto stack
    (.add (StringBuffer (. s "[]" from)))
    (.add do-read-token))
  (do-read-token state s (inc from) to))

(defn dispatch [^ReaderState state ^String s ^int from ^int to]
  (let [cu (.codeUnitAt s from)]
    (if-some [rd (when (< cu 128) (aget macros cu))]
      (rd state s (inc from) to)
      (read-token state s from to))))

(defn skip-space [^String s ^int from ^int to]
  (let [{end .-end} (.matchAsPrefix SPACE-REGEXP s from)]
    (if (< end to)
      end
      -1)))

(defn do-read
  ([^ReaderState {:flds [stack q] :as state}]
   (when (.-isEmpty q)
     (throw (Exception "EOF while reading")))
   (.removeLast stack))
  ([^ReaderState {:flds [stack q] :as state} ^String s ^int from ^int to]
   (if (.-isNotEmpty q)
     (do
       (.removeLast stack)
       from)
     (let [from (skip-space s from to)]
       (cond
         (neg? from) from
         (< from to)
         (let [from (dispatch state s from to)]
           (if (neg? from)
             from
             ; something has been read but the q may still be empty, let's loop to check!
             (recur state s from to)))
         :else -1)))))

(defn read
  [^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
  (if (-> state .-q .-isNotEmpty)
    from
    (do
      (.add stack do-read)
      (do-read state s from to))))

(defn read-coll
  [do-read-coll]
  (fn
    ([^ReaderState state] (throw (Exception "EOF encoutered, expecting closing delimiter.")))
    ([^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
     (doto stack
       (.add #dart [])
       (.add do-read-coll))
     (do-read-coll state s from to))))

(defn mk-do-read-coll [closing-delim mk-coll]
  (let [closing-cu (int closing-delim)]
    (fn
      ([^ReaderState state] (throw (Exception "EOF while reading")))
      ([^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
       (let [n-2 (- (.-length stack) 2)
             ^List items (aget stack n-2)]
         (loop [from (skip-space s from to)]
           (.addAll items q)
           (.clear q)
           (cond
             (neg? from) from
             (< from to)
             (if (== closing-cu (.codeUnitAt s from))
               (do
                 (.-length! stack n-2)
                 (.add q (mk-coll items))
                 (inc from))
               (let [from (read state s from to)]
                 (if (neg? from)
                   from
                   (recur from))))
             :else -1)))))))

;; a chunked reader is a stateful function with three arities:
;; EOF: [] -> ?
;; chunk [s from to] -> reader
;; result [x] -> reader

;; a chunked reader is a stateful function [string from to] -> i
;; when i < 0 all input was consumed
;; else reader is done and input upto i (excluded) is consumed
;; if string is nil then it means EOF

(def ^RegExp INT-REGEXP (RegExp. "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$"))
(def ^RegExp DOUBLE-REGEXP (RegExp "([-+]?[0-9]+([.][0-9]*)?([eE][-+]?[0-9]+)?)(M)?$"))
(def ^RegExp SYMBOL-REGEXP (RegExp "(?:([:]{2})|([:]))?(?:([^0-9/:].*)/)?(/|[^0-9/][^/]*)$"))

(defn terminating? ^bool [^String s ^int i]
  (some? (.matchAsPrefix #"[\s,;()\[\]{}\"~^@`\\]" s i)))

(defprotocol IResolver
  (currentNS [resolver])
  (resolveClass [resolver sym])
  (resolveAlias [resolver sym])
  (resolveVar [resolver sym]))

(def ^:dynamic *resolver* nil)

(defn interpret-token [^String token]
  (case token
    "nil" nil
    "true" true
    "false" false
    (if-some [m (.matchAsPrefix INT-REGEXP token)]
      (let [parse (if ^some (.group m 8)
                    (if (== "-" (.group m 1))
                      (fn ^BigInt [^String s ^int radix] (- (BigInt/parse s .radix radix)))
                      (fn ^BigInt [^String s ^int radix] (BigInt/parse s .radix radix)))
                    (if (== "-" (.group m 1))
                      (fn ^int [^String s ^int radix] (- (int/parse s .radix radix)))
                      (fn ^int [^String s ^int radix] (int/parse s .radix radix))))]
        (cond
          (not (nil? (.group m 2))) 0
          (not (nil? (.group m 3))) (parse (.group m 3) 10)
          (not (nil? (.group m 4))) (parse (.group m 4) 16)
          (not (nil? (.group m 5))) (parse (.group m 5) 8)
          (not (nil? (.group m 7))) (parse (.group m 7) (int/parse ^String (.group m 6)))
          :else (throw (FormatException. (str "Invalid number: " token ".")))))
      (if-some [m (.matchAsPrefix DOUBLE-REGEXP token)]
        (if (.group m 4)
          (throw (FormatException. "BigDecimal not supported yet."))
          (double/parse token))
        (if-some [^Match m (.matchAsPrefix SYMBOL-REGEXP token)]
          (let [g1 (.group m 1)
                g2 (.group m 2)
                g3 (.group m 3)
                g4 (.group m 4)]
            (when (or
                    (and g3 (.endsWith g3 ":/"))
                    (.endsWith g4 ":")
                    (not= -1 (.indexOf token "::" 1)))
              (FormatException. (str "Invalid token: " token)))
            (if g1
              (if-some [nsym (if g3 (resolveAlias *resolver* (symbol nil g3)) (currentNS *resolver*))]
                (keyword (name nsym) g4)
                (FormatException. (str "Invalid token: " token)))
              (if g2
                (keyword g3 g4)
                (symbol g3 g4))))
          (throw (FormatException. (str "Invalid token: " token))))))))

(def ^RegExp STRING-ESC-REGEXP
  #"\\(?:u([0-9a-fA-F]{0,4})|([0-7]{1,3})|(.))")

(defn- unesc [^String s]
  (.replaceAllMapped s
    STRING-ESC-REGEXP
    (fn [^Match m]
      (if-some [m1 (.group m 1)]
        (if (< (.-length m1) 4)
          (throw (FormatException (str "Unsupported escape for character: \\u" m1 " \\u MUST be followed by 4 hexadecimal digits")))
          (String/fromCharCode (int/parse m1 .radix 16)))
        (if-some [m2 (.group m 2)]
          (String/fromCharCode (int/parse m2 .radix 8))
          (let [m3 (.group m 3)]
            (case m3
              "\"" (str m3)
              "\\" (str m3)
              "b" "\b"
              "n" "\n"
              "r" "\r"
              "t" "\t"
              "f" "\f"
              (throw (FormatException (str "Unsupported escape character: \\" m3))))))))))

(defn do-read-stringlit
  ([^ReaderState state] (throw (Exception "EOF encoutered, string not properly terminated.")))
  ([^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
   (let [n-3 (- (.-length stack) 3)
         ^StringBuffer sb (aget stack (inc n-3))]
     (loop [from from ^bool esc (aget stack n-3)]
       (if (< from to)
         (let [cu (.codeUnitAt s from)]
           (if (and (not esc) (== 34 cu)) ; \"
             (do
               (.-length! stack n-3)
               (->> sb .toString unesc (.add q))
               (inc from))
             (do
               (.writeCharCode sb cu)
               (recur (inc from) (and (not esc) (== 92 cu)))))) ; \\
         (do
           (aset stack n-3 esc)
           -1))))))

(defn read-stringlit
  [^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
  (doto stack
    (.add false)
    (.add (StringBuffer))
    (.add do-read-stringlit))
  (do-read-stringlit state s from to))

#_(defn deref-reader [out!]
  (reader (fn [form] (out! (list 'deref form)))))

#_(defn discard-reader [out!]
  (reader (fn [form] nil)))

#_(defn meta-reader [out!]
  (let [closing-delim (int closing-delim)
        vchild (volatile! nil)
        items #dart[]
        item! #(.add items %)]
    (fn
      ([] (throw (Exception "EOF while reading")))
      ([^String s ^int from ^int to]
       (if-some [child @vchild]
         (let [r (child s from to)
               flush! (fn []
                        (if ))]
           (cond
             (neg? r) r
             (< (.-length items) 2)
             (do
               (vreset! vchild nil)
               (recur s r to))
             :else ))
           (let [from (space-skipper s from to)]
             (if (neg? from)
               from
               (if (== closing-delim (.codeUnitAt s from))
                 (do (out! (mk-coll items)) (inc from))
                 (do
                   (vreset! vchild (dispatch s from item!))
                   (recur s (inc from) to))))))))))

(defn do-read-meta
  ([^ReaderState {:flds [stack q] :as state}]
   (when (neg? (do-read-meta state "" 0 0))
     (throw (Exception "EOF while reading a value with metadata."))))
  ([^ReaderState {:flds [stack q] :as state} ^String s ^int from ^int to]
   (let [n-2 (- (.-length stack) 2)]
     (loop [from from]
       (let [from (read state s from to)]
         (if (neg? from)
           from
           (let [x (.removeFirst q)]
             (if-some [m (aget stack n-2)]
               (do
                 (.-length! stack n-2)
                 (.addFirst q (with-meta x m))
                 from)
               (let [m (cond
                         (map? x) x
                         (keyword? x) {x true}
                         (or (symbol? x) (string? x)) {:tag x}
                         :else (throw (Exception (str "Invalid value as metadata: " (pr-str x)))))]
                 (aset stack n-2 m)
                 (recur from))))))))))

(defn read-meta
  [^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
  (do
    (.add stack nil)
    (.add stack do-read-meta)
    (do-read-meta state s from to)))

(defn do-read-comment
  ([^ReaderState {:flds [stack]}] (.removeLast stack))
  ([^ReaderState {:flds [stack]} ^String s ^int from ^int to]
   (loop [from from]
     (if (< from to)
       (let [cu (.codeUnitAt s from)]
         (if (== 10 cu) ; newline
           (do
             (.removeLast stack)
             (inc from))
           (recur (inc from))))
       -1))))


(defn read-comment
  [^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
  (.add stack do-read-comment)
  (do-read-comment state s from to))

#_(defn ctor-reader [out!]
  (fn
    ([] (throw (Exception "EOF while reading")))
    ([^String s ^int from ^int to]
     (throw (Exception "TODO ctor-reader or only taglit")))))

#_(defn dispatch-macro-reader [out!]
  (let [vchild (volatile! nil)]
    (fn
      ([] (if-some [child @vchild]
            (child)
            (throw (Exception "EOF while reading"))))
      ([^String s ^int from ^int to]
       (if-some [child @vchild]
         (child s from to)
         (let [ch (.codeUnitAt s from)
               rdr (or (when (< ch 128) (aget dispatch-macros ch))
                     ctor-reader)
               r (vreset! vchild (rdr out!))]
           (r s (inc from) to)))))))

(defn do-read-dispatch-macro
  ([^ReaderState state] (throw (Exception "EOF encoutered after a #.")))
  ([^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
   (if (< from to)
     (let [cu (.codeUnitAt s from)]
       (if-some [rd (when (< cu 128) (aget dispatch-macros cu))]
         (do
           (.removeLast stack)
           (rd state s (inc from) to))
         (throw "TODO ctor"))))))

(defn read-dispatch-macro
  [^ReaderState {:flds [q stack] :as state} ^String s ^int from ^int to]
  (.add stack do-read-dispatch-macro)
  (do-read-dispatch-macro state s from to))

(defn unexpected [msg]
  (fn [_ _ _ _]
    (throw (FormatException (str "Unexpected " msg ".")))))

(def macros
  (doto (List/filled 128 nil)
    (aset (int "\"") read-stringlit)
    (aset (int "(") (read-coll (mk-do-read-coll ")" -list-lit)))
    (aset (int ")") (unexpected "closing parenthesis"))
    (aset (int "{")
      (read-coll (mk-do-read-coll "}"
                   (fn [kvs]
                     (if (even? (count kvs))
                       (-map-lit kvs)
                       (throw (FormatException "Map literal must contain an even number of forms")))))))
    (aset (int "}") (unexpected "closing curly brace"))
    (aset (int "[") (read-coll (mk-do-read-coll "]" vec)))
    (aset (int "]") (unexpected "closing square bracket"))
    (aset (int "^") read-meta)
    #_(aset (int "@") deref-reader)
    (aset (int "#") read-dispatch-macro)
    (aset (int ";") read-comment)))

(def dispatch-macros
  (doto (List/filled 128 nil)
    #_(aset (int "_") discard-reader)
    (aset (int "{") (read-coll (mk-do-read-coll "}" set)))))

(defn read-string [s]
  (let [state (ReaderState #dart [] (coll/Queue))]
    (read state "" 0 0)
    (.convert (CljDecoder state) s)))
